"""
Pydantic Schemas for Request/Response Validation

EDUCATIONAL: Pydantic for Data Validation
=========================================

What is Pydantic?
----------------
Pydantic is a data validation library that uses Python type hints:
- Automatic validation of incoming data
- Converts data to correct types
- Generates JSON schema for OpenAPI docs
- Provides clear error messages

Without Pydantic:
```python
def create_user(data: dict):
    # Manual validation ðŸ˜ž
    if 'email' not in data:
        raise ValueError("Email required")
    if not isinstance(data['age'], int):
        raise ValueError("Age must be integer")
    if data['age'] < 0:
        raise ValueError("Age cannot be negative")
    # ... many more checks
```

With Pydantic:
```python
class UserCreate(BaseModel):
    email: EmailStr  # Automatically validated âœ“
    age: int = Field(..., ge=0)  # Age >= 0 enforced âœ“
```

Benefits:
1. Less code
2. Type safety (IDE autocomplete works!)
3. Self-documenting (schema shows required fields)
4. Automatic API documentation generation
"""

from pydantic import BaseModel, Field, validator, EmailStr
from typing import Optional, List
from datetime import datetime
from enum import Enum


# =============================================================================
# ENUMS - Match database enums
# =============================================================================

class ConditionEnum(str, Enum):
    """Physical condition of property"""
    INTACT = "intact"
    PARTIAL_COLLAPSE = "partial_collapse"
    FULL_COLLAPSE = "full_collapse"
    FIRE_DAMAGE = "fire_damage"
    UNKNOWN = "unknown"


class AccessibilityEnum(str, Enum):
    """How safely the property can be accessed"""
    EASY = "easy"
    MODERATE = "moderate"
    DIFFICULT = "difficult"
    DANGEROUS = "dangerous"


# =============================================================================
# LOCATION SCHEMAS
# =============================================================================

class LocationBase(BaseModel):
    """
    Base schema with common fields.
    
    EDUCATIONAL: Schema Inheritance
    ------------------------------
    We use inheritance to avoid repeating fields:
    
    LocationBase (common fields)
      â”œâ”€â”€ LocationCreate (for POST requests)
      â”œâ”€â”€ LocationUpdate (for PUT/PATCH requests)
      â””â”€â”€ LocationResponse (for responses, adds id, created_at, etc.)
    
    This follows DRY principle (Don't Repeat Yourself)
    """
    latitude: float = Field(
        ...,  # ... means required, no default
        ge=-90,  # greater or equal to -90
        le=90,  # less or equal to 90
        description="Latitude coordinate (-90 to 90)",
        example=42.3314
    )
    longitude: float = Field(
        ...,
        ge=-180,
        le=180,
        description="Longitude coordinate (-180 to 180)",
        example=-83.0458
    )
    address: Optional[str] = Field(
        None,  # Optional field, defaults to None
        max_length=500,
        description="Street address if known",
        example="123 Main St, Detroit, MI 48201"
    )
    condition: ConditionEnum = Field(
        ...,
        description="Physical condition of the structure"
    )
    accessibility: AccessibilityEnum = Field(
        ...,
        description="How safely the property can be accessed"
    )
    notes: Optional[str] = Field(
        None,
        max_length=1000,
        description="Any additional notes about this location"
    )


class LocationCreate(LocationBase):
    """
    Schema for creating a new location.
    
    EDUCATIONAL: Create vs Update Schemas
    ------------------------------------
    Create schema:
    - All required fields must be provided
    - No ID (generated by database)
    - No timestamps (set by database)
    
    Update schema:
    - All fields optional (partial updates)
    - ID in URL path parameter
    - Timestamps updated automatically
    """
    confirmed: bool = Field(
        False,  # Default to unconfirmed
        description="Whether this location has been human-verified"
    )
    
    # EDUCATIONAL: Custom Validators
    #
    # Use @validator for complex validation:
    # - Cross-field validation (e.g., end_date must be after start_date)
    # - External API calls (e.g., check if address exists)
    # - Business logic (e.g., can't create duplicate within 100m)
    @validator('notes')
    def validate_notes_length(cls, v):
        """
        Custom validation for notes field.
        
        cls: The class being validated (LocationCreate)
        v: The value of the 'notes' field
        """
        if v and len(v) > 1000:
            raise ValueError('Notes must be 1000 characters or less')
        return v
    
    @validator('address')
    def validate_address(cls, v):
        """Ensure address doesn't contain suspicious content"""
        if v and any(bad_word in v.lower() for bad_word in ['<script>', 'javascript:']):
            raise ValueError('Address contains invalid characters')
        return v
    
    class Config:
        """
        Pydantic configuration.
        
        EDUCATIONAL: Schema Configuration
        ---------------------------------
        schema_extra: Provides example for API documentation
        - Shows up in Swagger UI
        - Helps users understand expected format
        """
        schema_extra = {
            "example": {
                "latitude": 42.3314,
                "longitude": -83.0458,
                "address": "1234 Abandoned St, Detroit, MI 48201",
                "confirmed": False,
                "condition": "partial_collapse",
                "accessibility": "moderate",
                "notes": "Broken windows, overgrown yard. Appears vacant for 2+ years."
            }
        }


class LocationUpdate(BaseModel):
    """
    Schema for updating a location.
    
    EDUCATIONAL: Partial Updates
    ---------------------------
    All fields are Optional for PATCH requests:
    - Only send fields you want to update
    - Other fields remain unchanged
    - Reduces data transfer and mistakes
    
    Example:
        PATCH /locations/123
        {"condition": "full_collapse"}
        # Only updates condition, leaves other fields alone
    """
    latitude: Optional[float] = Field(None, ge=-90, le=90)
    longitude: Optional[float] = Field(None, ge=-180, le=180)
    address: Optional[str] = Field(None, max_length=500)
    confirmed: Optional[bool] = None
    condition: Optional[ConditionEnum] = None
    accessibility: Optional[AccessibilityEnum] = None
    notes: Optional[str] = Field(None, max_length=1000)


class LocationResponse(LocationBase):
    """
    Schema for location responses.
    
    EDUCATIONAL: Response Schemas
    ----------------------------
    Response schemas include:
    - All fields from base schema
    - Generated fields (id, created_at, updated_at)
    - Related data (photos count, predictions, etc.)
    
    orm_mode=True:
    - Allows creating schema from SQLAlchemy model
    - Example: LocationResponse.from_orm(db_location)
    - Without this, you'd need to manually convert model to dict
    """
    id: str = Field(..., description="Unique identifier (UUID)")
    confirmed: bool
    confidence_score: Optional[float] = Field(
        None,
        description="ML model confidence score (0-1) if this was a prediction"
    )
    created_at: datetime = Field(..., description="When this location was created")
    updated_at: datetime = Field(..., description="When this location was last updated")
    
    # Optional: Include related data
    # photos_count: int = 0
    
    class Config:
        """
        EDUCATIONAL: ORM Mode
        --------------------
        orm_mode=True allows creating Pydantic models from ORM models:
        
        Without orm_mode:
            location_dict = {
                "id": db_location.id,
                "latitude": db_location.latitude,
                # ... manually copy all fields
            }
            return LocationResponse(**location_dict)
        
        With orm_mode:
            return LocationResponse.from_orm(db_location)
        
        Much cleaner!
        """
        orm_mode = True
        schema_extra = {
            "example": {
                "id": "550e8400-e29b-41d4-a716-446655440000",
                "latitude": 42.3314,
                "longitude": -83.0458,
                "address": "1234 Abandoned St, Detroit, MI 48201",
                "confirmed": True,
                "condition": "partial_collapse",
                "accessibility": "moderate",
                "notes": "Verified by field team",
                "confidence_score": 0.89,
                "created_at": "2024-01-15T10:30:00Z",
                "updated_at": "2024-01-15T10:30:00Z"
            }
        }


class LocationListResponse(BaseModel):
    """
    Schema for paginated location lists.
    
    EDUCATIONAL: Pagination Response Format
    --------------------------------------
    Best practice for list endpoints:
    - items: The actual data
    - total: Total count (for "Page 1 of 10")
    - skip: Offset used (for "Showing 20-40 of 200")
    - limit: Page size
    - Optional: next_page_url, prev_page_url
    
    Why include total?
    - User knows how much data exists
    - Can calculate total pages
    - Can show progress bar
    
    Why include skip/limit?
    - User knows what slice they're viewing
    - Can construct next page request
    """
    items: List[LocationResponse] = Field(..., description="List of locations")
    total: int = Field(..., description="Total number of locations matching filters")
    skip: int = Field(..., description="Number of records skipped")
    limit: int = Field(..., description="Maximum number of records returned")
    
    class Config:
        schema_extra = {
            "example": {
                "items": [
                    # ... locations here
                ],
                "total": 150,
                "skip": 0,
                "limit": 20
            }
        }


# =============================================================================
# PHOTO SCHEMAS
# =============================================================================

class PhotoResponse(BaseModel):
    """Photo metadata response"""
    id: str
    location_id: str
    file_path: str
    thumbnail_path: Optional[str]
    photo_type: str
    taken_at: Optional[datetime]
    created_at: datetime
    
    class Config:
        orm_mode = True


# =============================================================================
# VALIDATION MESSAGES
# =============================================================================

# EDUCATIONAL: Custom Error Messages
#
# Pydantic's default errors are good but can be improved:
# Default: "value is not a valid float"
# Custom: "Latitude must be a number between -90 and 90"
#
# To customize error messages, use Field(description=...) or custom validators
# that raise ValueError with clear messages
